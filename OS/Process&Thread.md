# 프로세스

프로세스를 여러게 돌리는 멀티태스킹 이전에는 파일 다운로드 시, 모든게 멈췄었다. 한번에 하나씩만 가능 했었다.

## Process

* 컴퓨터가 어떤 일을 하고 있는 상태
* 컴퓨터에서 실행되고 있는 프로그램. CPU 스캐줄링의 대상
  * ex) 윈도우 작업관리자의 백그라운드 프로세스
* 프로세스는 프로그램으로부터 인스턴스화 된것이다.
  * ex) 구글 크롬.exe파일은 실행파일이다. 이를 실행시키면 구글 크롬 '프로세스'가 시작된다

#### **동시성**

* 프로세스 하나가 여러가지를 돌아가면서, 일부분씩 진행 하는 것
* 싱글코어도 사람이 인식할 수 없는 속도로 여러가지를 돌아가면서 하기에, 멀티 프로세스 실행이 가능

#### **병렬성**

* 프로세스 하나에 코어가 여러개 달려서 각각 동시에 작업
* 멀티코어 프로세스가 달린 컴퓨터에서 가능
* 발열등 물리적 제약으로 CPU의 성능이 예전처럼 증가하기 어렵기 때문에 멀티코어로 작업을 분담 할 수 있도록

![](../.gitbook/assets/2022-06-06\_13-21-24.png)

### 컴파일 과정 (c언어)

* 프로그램은 컴파일러가 컴파일 과정을 거쳐 컴퓨터가 이해할 수 잇는 기어로 번역되어 실행될 수 있는 파일이 되는 것

![C언어 빌드 과정 with gcc - 서준수](../.gitbook/assets/2022-06-06\_13-05-46.png)

#### 전처리

소스 코드의 주석을 제거하고 #include등 헤더 파일을 병합하여 매크로를 치환

#### 컴파일러

오류 처리, 코드 최적화 작업을 하며 어셈ㄹ리어로 변환

#### 어셈블러

어셈블리어는 목적코드(obhect code)로 변환한다. 이떄 확장자는 운영체제 마다 다른데 리눅스에서는 .o이다.&#x20;

#### 링커

프로그램 내에 잇는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만든다. 확장자는 .exe 또는 .out을 가진다.



#### 정적라이브러리

* 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식.&#x20;
* 장점) 시스템 환경 등 외부 의존도가 낮다.
* 단점) 코드 중복 등 메모리 효율성이 떨어진다.

#### 동적라이브러리

* 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하는 방식
* 장점) 메모리 효율성
* 단점) 외부 의존도가 높아진다



### 프로세스의 상태

![\[운영체제 이론\] 프로세스(process) (tistory.com)](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2\&fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2515314C56BF379A05C76E)

프로세스는 여러가지 상태 값을 가진다.

#### 생성 상태

생성 사태는 프로세스가 생성된 상태를 의미하며 fork(), exec()함수를 해 생성한다. 이때 PCB가 할당된다.

* fork(): 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수. 주소 공간만 복사할 뿐이지 프로세스의 비동기 작업 등을 상속하지는 않는다.
* exec(): 새롭게 프로세스를 생성하는 함수

#### 대기상태

대기상태는 메모리 공간이 충ㄴ하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있다.&#x20;

CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상

* 대기 중단 상태: 메모리 부족으로 일시 중단된 상태

#### 실행상태

CPU 소유권과 메모리를 당받고 인스트러견을 수행 중인 상태. CPU brust가 일어났다고 표현한다

#### Block(중단상태)

어떤 이벤트가 발생한 이후 기다리며 프로세스가 차찬된 상태&#x20;

I/O 디바이스으로 인한 인터럽트로 이런 현상이 많이 발생하기도 한다.

* ex) 프린트 인쇄 버튼 눌렀을때 프로세스가 잠깐 멈춘 듯 할 때

#### 종료 상태

메모리와 CPU 소유권을 모두 놓고 가는 상태.

자연스럽게 종료되기도 하고, 부모가 자식프로세스를 강제시키는 비자발적 종료(abort)도 있다.



### 프로세스의 메모리 구조

운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당한다.

> 프로그램이 CPU에 의해 실행됨 → 프로세스가 생성되고 메모리에 \*\*'프로세스 주소 공간'\*\*이 할당됨

프로세스 주소 공간에는 코드, 데이터, 스택으로 이루어져 있다.

#### 동적영역

* **스택 Segment** : 함수, 지역 변수 저장 컴파일 시에 크기가 결정되며 동적이다.함수가 재귀적으로 호하며 동적으로 크기가 늘어날 수 있기에 힙과 스택의 메모리 영역이 겹치지 않도록 공간을 비워 놓는다.
* **힙:** 동적 할당할 떄 사용. 런타임 시 크기가 결정된다.&#x20;

#### 정적영역

* **코드 Segment** : 프로그램 소스 코드 저장
* **데이터 Segment** : 전역 변수 저장

\


_**왜 이렇게 구역을 나눈건가요?**_

최대한 데이터를 공유하여 메모리 사용량을 줄여야 합니다.

Code는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유함

Stack과 데이터를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위한 것!

\


![](https://camo.githubusercontent.com/c98b302e6bd4eaf6f2c81cb1ebb1dda95448b6154c9abefca915207fc635478e/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323137343031333835384631424544373041)



## 참고자료

* [C언어 빌드 과정 with gcc - 서준수](https://brunch.co.kr/@mystoryg/57)
* [\[운영체제 이론\] 프로세스(process) (tistory.com)](https://arer.tistory.com/79)
* [프로세스는 뭐고 스레드는 뭔가요? - YouTube](https://www.youtube.com/watch?v=iks\_Xb9DtTM)
